{% load static %}
{% load bootstrap5 %}
<!DOCTYPE html>
<html>
<head>
    <title>{% block title %}{% endblock %}</title>
    {% bootstrap_css %}
    <!-- Include jQuery from a CDN -->
    <script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""></script>

    <style>
        html, body, main {
    height: 100%;
    margin: 0;
    padding: 0;
}
.container-fluid {
    height: 100%;
}

.row, .col-md-6, .iss-photo-container {
    height: 100%;
}
.tools{

}
        .iss-photo-container {
           
            overflow: hidden;
            position: relative;
        }
        .column-left {
            z-index: 2;
           
        }
        .zindex2 {
            z-index: 2;
        }
        .container-fluid {
            height: 100%;
        }

        #iss-photo {
            width: 100%;
            height: auto;
            margin-top: auto;
            transform-origin: center center;
            
            transition: transform 0.3s ease;
            z-index: -100;
        }
        #map { 
            height: 300px;
            width: 100%;
        }
    </style>

</head>
<body>
    <!--header>
        <h1>My Website</h1>
        <nav>
            <ul>
                <li><a href="">Home</a></li>
                <li><a href="">About</a></li>
                <li><a href="">Contact</a></li>
            </ul>
        </nav>
    </header!-->

    <main>
        {% block content %}{% endblock %}
    </main>

   
    {% bootstrap_javascript %}
    <script>
  
    $(document).ready(function () {
        var map = L.map('map').setView([51.505, -0.09], 13);
        L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
}).addTo(map);
      // Initialize variables
let scale = 1;
let rotation = 0;
let translateX = 0, translateY = 0;
let isDragging = false; // For left-click drag to move
let isRightClickDragging = false; // For right-click drag to rotate
let startX, startY; // Initial mouse positions for dragging and rotating

// Mouse wheel event for zoom
$('#iss-photo').on('wheel', function (event) {
    // Prevent the default scroll behavior
    event.preventDefault();

    // Check the direction of the scroll
    if (event.originalEvent.deltaY < 0) {
        // Zoom in
        scale += 0.1; // Adjust the zoom factor as needed
    } else {
        // Zoom out, ensuring the scale does not go below a minimum value
        scale = Math.max(scale - 0.1, 0.1);
    }

    // Update the transform with the new scale
    updateTransform();
});

// Mouse down event for dragging or rotating
$('#iss-photo').on('mousedown', function (event) {
    event.preventDefault(); // Prevent default behavior to avoid text selection or context menu

    if (event.button === 0) {
        // Left-click to drag
        isDragging = true;
        startX = event.pageX ;
        startY = event.pageY ;
    } else if (event.button === 2) {
        // Right-click to rotate
        isRightClickDragging = true;
        startX = event.pageX;
    }
});

// Mouse move event to handle dragging or rotating
$(document).on('mousemove', function (event) {
    if (isDragging) {
          // Left-click dragging to move
        const deltaX = event.pageX - startX;
        const deltaY = event.pageY - startY;

        // Convert rotation angle to radians
        const rad = rotation * (Math.PI / 180);

        // Calculate new translation values based on rotation
        translateX = (deltaX * Math.cos(rad)) + (deltaY * Math.sin(rad));
        translateY = (deltaY * Math.cos(rad)) - (deltaX * Math.sin(rad));
        //translateX = event.pageX - startX;
        //translateY = event.pageY - startY;
        updateTransform();

        // Update start positions for next move
        //startX = event.pageX;
        //startY = event.pageY;
    } else if (isRightClickDragging) {
        // Right-click dragging to rotate
        const deltaX = event.pageX - startX;

        // Adjust rotation angle based on mouse movement
        rotation -= deltaX * 0.2; // Adjust the multiplier for sensitivity

        // Update the transform with the new rotation angle
        updateTransform();

        // Update the starting X position for the next movement
        startX = event.pageX;
    }
});

// Mouse up event to stop dragging or rotating
$(document).on('mouseup', function (event) {
    if (event.button === 0) {
        // Stop left-click dragging
        isDragging = false;
        translateX = 0;
        translateY = 0;
    } else if (event.button === 2) {
        // Stop right-click dragging
        isRightClickDragging = false;
        translateX = 0;
        translateY = 0;
    }
});

// Prevent the default context menu on right-click
$('#iss-photo').on('contextmenu', function (event) {
    event.preventDefault();
});

// Button events
$('#zoom-out').click(function () {
    scale = Math.max(0.1, scale - 0.1); // Decrease scale by 0.1, minimum scale is 0.1
    updateTransform();
});

$('#rotate-left').click(function () {
    rotation -= 5; // Decrease rotation angle by 5 degrees
    updateTransform();
});

$('#rotate-right').click(function () {
    rotation += 5; // Increase rotation angle by 5 degrees
    updateTransform();
});

// Function to update the transform properties
function updateTransform() {
    $('#iss-photo').css('transform', `scale(${scale}) rotate(${rotation}deg) translate(${translateX}px, ${translateY}px)`);
}
   
        

        $('#iss-photo').on('click', function () {
            let text = "";

            // The distace from the (0,0) to the center, but the offset of the parent
            distX = this.parentElement.offsetLeft + this.parentElement.width / 2;
            distY = this.parentElement.offsetTop + this.parentElement.height / 2;
            text += `Distance X: ${distX.toFixed(2)}, Distance Y: ${distY.toFixed(2)}<br>`;

            // Get the bounding rectangle of the rotated and scaled image
            const rect = this.getBoundingClientRect();
            text += `Bounding Rect: ${JSON.stringify(rect)}<br>`;

            // Calculate the center of the image in the current transformed frame
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            text += `Center X: ${centerX.toFixed(2)}, Center Y: ${centerY.toFixed(2)}<br>`;

            // Get the click position relative to the viewport
            const clickX = event.clientX;
            const clickY = event.clientY;

            // Translate the click position to the image's center-based coordinate system
            const translatedX = (clickX - centerX) / scale;
            const translatedY = (clickY - centerY) / scale;

            // So, if no rotation is applied, the image center is the origin
            // and the click position is the translated position
            text += `Translated X: ${translatedX.toFixed(2)}, Translated Y: ${translatedY.toFixed(2)}<br>`;

            // Convert rotation to radians
            const rad = (Math.PI / 180) * rotation;

            // Calculate the inverse rotation matrix to map the click back to the original image coordinates
            const cosTheta = Math.cos(-rad);
            const sinTheta = Math.sin(-rad);

            // Apply the inverse transformation matrix to get the original image coordinates
            const originalX = (translatedX * cosTheta - translatedY * sinTheta) 
            const originalY = (translatedX * sinTheta + translatedY * cosTheta) 
            text += `Original X: ${originalX.toFixed(2)}, Original Y: ${originalY.toFixed(2)}<br>`;

            // Now, we add the center of the image to get the final coordinates
            const finalX = originalX + centerX;
            const finalY = originalY + centerY;
            text += `Final X: ${finalX.toFixed(2)}, Final Y: ${finalY.toFixed(2)}<br>`;

            // Get the natural size of the image (its original resolution)
            const naturalWidth = this.naturalWidth;
            const naturalHeight = this.naturalHeight;

            // Calculate the size ratio between the displayed size and the natural size
            const ratioX = naturalWidth / (rect.width / scale);
            const ratioY = naturalHeight / (rect.height / scale);

            // Adjust coordinates to the original resolution
            const px = originalX * ratioX;
            const py = originalY * ratioY;

            // Display the adjusted coordinates
            $('#coordinates').html = text;
            $('#coordinates').html(text);
            console.log(text);
        });
    });
</script>
    
</body>
</html>